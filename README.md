# nand2tetris
Noam Nisan, Shimon Schocken著
[『コンピュータシステムの理論と実装』](https://www.amazon.co.jp/dp/4873117127/)
(オライリー・ジャパン刊)
の各章に用意されているプロジェクトの成果物．

## まえがき
### 本書の扱う範囲
本書をがカバーするトピックは、モダンなコンピュータをゼロから
作り上げる、という明確な目的のもとで組まれているが、
トピックの数は最小限に抑えている．例えば、最適化という
重要な問題についてはあまり注意を払っていない．

## イントロダクション: こんにちは、世界の下側
本書では、実践的な作業を通じて完全なコンピュータシステム
をゼロから作り上げていく．まず基本となる論理ゲートから始め
(1章)、順序回路と組み合せ回路へと進む(2～3章)．さらに
一般的なコンピュータアーキテクチャを設計し(4～5章)、
一般的なソフトウェア階層を構築する(6～8章)．そして、
モダンなオブジェクトベースの言語(9章)のためのコンパイラ
を実装するに至る(10～11章)．最終的にシンプルなOSの
設計と実装を行う(12章)．

## 1章 ブール論理
最も単純な論理ゲートの1つであるNANDゲートから始め、
その他全ての論理回路をNANDゲートから作成していく．
結果として、より一般的な論理回路ができあがり、
後ほどコンピュータの処理とストレージ用の回路を
作るときに用いられる．

## 2章 ブール算術
数を表現し算術演算を行うための論理ゲートを作成する．
出発点は1章で作成した論理ゲートであり、終着点は
算術論理演算器(ALU)である．コンピュータで行われる
算術演算と論理演算は全て、このALU回路によって行われる．
そのため、ALUの機能を理解することは、CPUさらには
コンピュータ全体の仕組みを理解する上で重要なステップとなる．

## 3章 順序回路
コンピュータは値を計算するだけでなく、その値を呼び出す
ことができなければならない．そのため、時間が経過しても
データを記憶できる記憶素子を備える必要がある．
この記憶素子は順序回路から構築できる．本章では、
フリップフロップをプリミティブな構成要素として
2値素子からレジスタ・メモリ・カウンタと順を追って
構築していく．

## 4章 機械語
新しいコンピュータシステムに慣れ親しむためには、
機械語で書かれたプログラムをいくつか見るのが手っ取り早い．
これは何か有用なことを実行する方法を理解するためだけでなく、
ハードウェアがなぜそのように設計されているかを理解するため
にも役立つ．その点を考慮して、本章では機械語による低水準の
プログラミングに焦点を当てる．本章は次章のために前準備である．

## 5章 コンピュータアーキテクチャ
1～3章までに作成した回路を用いて汎用コンピュータを構築する．
この汎用コンピュータはメモリ(3章)に格納された機械語プログラム
(4章)をALU(2章)を駆使して実行することができる．

## 6章 アセンブラ
ソフトウェア階層において最初のモジュールであり、
最も基礎となるモジュールがアセンブラである．
本章では、アセンブリ言語で書かれたプログラムを、
5章で作成したハードウェアのプラットフォーム上で
実行できるバイナリコードへと変換するアセンブラを開発する．

## 7章 VM#1: スタック操作
本章はコンパイラの構築へ向けた第一歩である．コンパイラを
作るという作業は相当に困難であるため、本書ではそれを2段階に
分けて取り組むことにする．この2つの段階にはそれぞれ2章が
割かれ、合計で4章に渡る．本書で提示するVMはスタックを
ベースとしたものである．

本章と次章では、VMプログラムをアセンブリコードへと変換する
**VM変換器**を実装する．VMプログラムを記述するための
VM言語には以下の4つのコマンドが含まれる．

- 算術コマンド
- メモリアクセスコマンド
- プログラムフローコマンド
- サブルーチン呼び出しコマンド

本章では前半2つのコマンドを変換するベーシックなVM変換器
を実装する．次章で後半2つの機能を備えるように変換器を
拡張する．結果として完全なVMができあがり、これは
10～11章で作るコンパイラのバックエンドとして動くことになる．

## 8章 VM#2: プログラム制御
前章から引き続きVM実装の開発を行う。特に、手続き型言語や
オブジェクト指向言語のネスト化されたサブルーチン呼び出し
を扱う。前章で構築した基本となるVM変換器を拡張し、
完全版のVM変換器へと至る．

## 9章 高水準言語
本章の目的はJack言語について慣れ親しみ、この先に待ち受ける
コンパイラとオペレーティングシステムの開発に対して準備する
ことである．単純なゲームやインタラクティブなプログラムなど、
Jackで開発したいアプリケーションを考える。アプリケーション
開発のガイドラインとして、4つのサンプルアプリケーションを
紹介する。そして、考えたアプリケーションの設計と実装を行う．

## 10章 コンパイラ#1 構文解析
コンパイルは概念的に構文解析とコード生成という2つの作業に
基づいている．本章では、構文解析に焦点を当て、コード生成
機能を備えない構文解析器を作る．本章の構文解析器だけのために
独立してユニットテストを行うには、ソースプログラムを
"理解している"ことを示す何らかの方法を考えなければならない．
解決策として、ここではXMLファイルを出力させる方法を採用した．

## 11章 コンパイラ #2 コード生成

10章で作った構文解析器を拡張し、完全版のJackコンパイラを
完成させる．具体的には、XMLコードを生成するモジュールを、
実行可能なVMコードを生成するモジュールへと段階的に置き換える．

## 12章 オペレーティングシステム
Jackを用いて簡単なOSを実装する．本章で目標とするOSはミニマルな
構成であり、提供するサービスも最小限に抑えてある．このOSは、
次の2つのことを目標として設計されている．

- ハードウェアに特化したサービスをカプセル化し、
  ソフトウェアから使いやすいサービスを提供すること．
- 高水準言語を様々な関数と抽象データで拡張すること．

このOSはJackの標準ライブラリとしてパッケージされ、それぞれが
Jackのサブルーチン呼び出しを通して関連するサービスを提供する．
結果としてできあがるOSは商用のOSと似た特徴を持つが、
プロセス処理やディスク管理、通信などといった商用OSが持つ機能
を欠いている．

## 13章 その先へ
読者が修正や拡張を行えるようにするために、本書で使用した
ソフトウェアは全て、そのソースコード(Java)をオープンソース
として公開されている．ソフトウェアおよびドキュメントは、本書の
Webサイトから取得できる．本章では、筆者らが思いつく設計案が
いくつか紹介されている．

### ハードウェアの実現
本書で提示したハードウェアモジュールは全てHDLでシミュレート
したものであった．しかし、このHDLによる設計図をシリコンへと
移し、"本物のコンピュータ"として動かすことも不可能ではない．

### ハードウェアの改良
現時点のHackアーキテクチャにおいては、物理的なROM回路を
丸ごと取り替える以外に、ユーザ操作によって別のプログラム
をコンピュータに読み込む方法はない．

### 高水準言語
本書で開発したJack言語には不満な点がたくさん残されている．
例えば、Jackはオブジェクト指向の言語であるが、「継承」を
サポートしていない．

### 最適化
本書では「最適化」について、そのほとんどを省略した．
最適化は、全てのハッカーにとって"偉大なる競技場"である．

### 通信
Hackコンピュータをインターネットにつなぐことができた
とすれば、素敵なことではないだろうか．そのためには、
ビルトインの通信回路をハードウェアに追加し、高水準の
通信プロトコルを扱うためのコードを書く必要があるだろう．
